---
layout:     post
title:      卷积网络基本原理
subtitle:   卷积网络基本原理
date:       2017-10-05
author:     HR
header-img: img/post-bg-cnn.jpg
catalog: true
tags:
    - 深度学习
    - 神经网络
    - CNN

---


### 卷积网络概述 

卷积神经网络（Convolutional Neural Network,CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。它包括卷积层(alternating convolutional layer)和池层(pooling layer)。

 
### 卷积网络的结构
![](img/post-bg-cnn.jpg)

  最左边：

是数据输入层，对数据做一些处理，比如去均值（把输入数据各个维度都中心化为0，避免数据过多偏差，影响训练效果）、归一化（把所有的数据都归一到同样的范围）、PCA/白化等等。CNN只对训练集做“去均值”这一步。

  中间是：

CONV：卷积计算层，线性乘积 求和。
RELU：激励层，上文2.2节中有提到：ReLU是激活函数的一种。
POOL：池化层，简言之，即取区域平均或最大。
   
 最右边是：

FC：全连接层
## CNN之卷积计算层
### 什么是卷积
首先，我们来了解下什么是卷积操作。
    对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的权重固定，所以又可以看做一个恒定的滤波器filter）做内积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。
    比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter，图中右边是输出的新的二维数据。
 ![](http://img.blog.csdn.net/20160702215705128)

### 动态卷积图 

![](https://cs231n.github.io/assets/conv-demo/index.html)

随着左边数据窗口的平移滑动，滤波器Filter w0对不同的局部数据进行卷积计算。
    值得一提的是：
左边数据在变化，每次滤波器都是针对某一局部的数据窗口进行卷积，这就是所谓的CNN中的局部感知机制。
与此同时，数据窗口滑动，但中间滤波器Filter w0的权重（即每个神经元连接数据窗口的的权重）是固定不变的，这个权重不变即所谓的CNN中的参数共享机制。
    我第一次看到上面这个动态图的时候，只觉得很炫，另外就是据说“相乘后想加”，但到底具体是个怎么相乘后想加的过程 则无法一眼看出，网上也没有一目了然的计算过程。本文来细究下。
```

### 字符串改动


### String 操作简化了

`String` 许多要通过 `.characters` 进行的操作，可以直接用 String 进行操作了。

例如：

```swift
let greeting = "Hello, 😜!"
// No need to drill down to .characters
let n = greeting.count
let endOfSentence = greeting.index(of: "!")!

```

### 新增 Substring 类型


swift 4 为字符串片段新增了一个叫 `Substring` 的类型。

当你创建一个字符串的片段时，会产生一个 `Substring` 实例。`Substring` 与 `String` 用法相同， 因为子串和原字符串共享内存，所以对子串的操作快速而且高效。

```swift
let greeting = "Hi there! It's nice to meet you! 👋"
let endOfSentence = greeting.index(of: "!")! 

// 产生 Substring 实例
let firstSentence = greeting[...endOfSentence]
// firstSentence == "Hi there!"

// `Substring` 与 `String` 用法相同
let shoutingSentence = firstSentence.uppercased()
// shoutingSentence == "HI THERE!" 
```

但是要注意一个 `Substring` 保留从其生成的完整的 `String`值。 当您传递一个看似很小的 `Substring` 时，这可能导致意外的高内存开销。所以使用 `Substring`时，最好转化为 `String`.

```swift
let newString = String(substring)
```


#### 换行可以不用 `\n`了！

Swift 3，字符串换行要插入 `\n`。
例如：

![](https://ws4.sinaimg.cn/large/006tNc79gy1fjdam0wvhhj305d0283yf.jpg)

在 Swift 4 可以这样操作:

![](https://ws2.sinaimg.cn/large/006tNc79gy1fjdas2yri4j303q0260sm.jpg)

用两个 `“”“` 包裹起来的字符串会自动添加 `\n` 换行，更加直观了。注意：换行与缩进参照的是第二个 `“”“` 号的位置。

嗯，我觉得OK！

#### 支持 Unicode 9

Swift 4 支持 Unicode 9，[为现代表情符号修正了一些问题](https://oleb.net/blog/2016/12/emoji-4-0/)。


```swift
let family1 = "👨‍👩‍👧‍👦"
let family2 = "👨\u{200D}👩\u{200D}👧\u{200D}👦"
family1 == family2 // → true
```

居然还有这种操作~

### 新增 KeyPath 数据类型

KeyPath 是 Swift 4 新增加的数据类型。

定义两个结构体 `Person`与`Book` 

```swift
struct Person {
    var name: String
}

struct Book {
    var title: String
    var authors: [Person]
    var primaryAuthor: Person {
        return authors.first!
    }
}

let abelson = Person(name: "Harold Abelson")
let sussman = Person(name: "Gerald Jay Sussman")
let book = Book(title: "Structure and Interpretation of Computer Programs", authors: [abelson, sussman])
```
```swift
book[keyPath: \Book.title]
book[keyPath: \Book.primaryAuthor.name]
// 相当与
book.title
book.primaryAuthor.name
```

这里 `\Book.title` 与 `\Book.primaryAuthor.name` 就是 KeyPath.

KeyPath 可以用 `.appending` 拼接

```swift
let authorKeyPath = \Book.primaryAuthor
let nameKeyPath = authorKeyPath.appending(path: \.name)
// nameKeyPath = \Book.primaryAuthor.name
```

### 新增  `swapAt()` 函数
Swift 4 引入了一种在集合中交换两个元素的新方法: `swapAt()`

Swift 3 交换集合中的元素的用 `swap()`

```swift
var numbers = [1,2,3,4,5]
swap(&numbers[0], &numbers[1])
// numbers = [2,1,3,4,5]
```

Swift 4 中可以直接用 

```swift
var numbers = [1,2,3,4,5]
numbers.swapAt(0,1)
// numbers = [2,1,3,4,5]
```



### 其他改动

其他改动如：**新的整数协议**、**泛型下标**、**NSNumber bridging**等

可以参考：[whats new in swift4](https://github.com/ole/whats-new-in-swift-4)


